const createClassHelpers = require("./classHelpers");
const ASTVisitor = require("./ASTVisitor");

module.exports = (function() {
	function pvtData() {
		return {
			vocabulary: [], //keys and regex expressions
			functions: {}, //keys and function body strings
			terminalIndex: 0,
			indent: 0,
			pad() {
				let p = getPrivate(this, "pad", true);
				return Array(p.indent+1).join("    ");
			},
			getRegex(term) {
				let chars = term.split();

				for (let i=0; i<chars.length; ++i) {
					if ("{}()[]?>*+-".includes(chars[i])) {
						chars[i] = "\\" + chars[i];
					}
				}

				return RegExp(chars.join()).toString();
			}
		};
	}

	class EBNF_AST2JS extends ASTVisitor {
		constructor(types) {
			super(types);
			let p = makePrivates(this, new.target);

			this.validateVisitor();
		}

		Grammar(node) {
			let p = getPrivate(this, "Grammar");
			let retval = `//Generated By chevrotain_ebnf\n` +
						 `const createClassHelpers = require("./lib/classHelpers");\n` +
						 `const { Lexer, Parser, createToken, createSyntaxDiagramsCode } = require("chevrotain");\n` +
						 `const fs = require("fs");\n\n`;


			for (let rule of node.rules) {
				this.visit(rule);
			}

			//Time to assemble the pieces. Vocabulary first.
			retval += `let Vocabulary = {\n`;
			++p.indent;

			for (let term of p.vocabulary) {
				let vocabName = `VocabTerm$${p.terminalIndex++}`;
				retval += `${p.pad()}${vocabName}: createToken({\n`;
				++p.indent;
				retval += `${p.pad()}name: \`/${vocabName}/\`,\n`;
				retval += `${p.pad()}pattern: \`${p.getRegex(term)}\`,\n`;
				--p.indent;
				retval += `${p.pad()}}),\n`
			}
			--p.indent;
			retval += `${p.pad()}};\n\n`;

			//Now extract the tokens from the vocabulary.
			retval += `${p.pad()}let Tokens = Object.values(Vocabulary);\n\n`;

			//Finally, time to create the parser class
			retval += `${p.pad()}module.exports = class extends Parser {\n`;

			
			return retval;
		}

		Rule(node) {
			let p = getPrivate(this, "Rule");
			p.functions[node.name.value] = `let $ = this;\n\n${this.visit(node.definition), null, '   '}`;
		}

		Definition(node) {
			let p = getPrivate(this, "Definition");
			let retval = "";
			let needOR = node.alternatives.length > 1;
			
			if (needOR) {
				retval += `${p.pad()}$.OR([\n`;
				++p.indent;
			}

			for (let alt of node.alternatives) {
				if (needOR) {
					retval += `${p.pad()}{\n`;
					++p.indent;
					retval += `${p.pad()}Alt: () => {\n`;
					++p.indent;
				}
				retval += this.visit(alt);
				if (needOR) {
					--p.indent;
					retval += `${p.pad()}}\n`;
					--p.indent;
					retval += `${p.pad()}},\n`;					
				}
			}

			if (needOR) {
				--p.indent;
				retval += `]);`;
			}

			return retval;
		}

		Sequence(node) {
			let retval = "";
			
			for (let element of node.value) {
				retval += this.visit(element);
			}

			return retval;
		}

		Alternate(node) {
			let retval = this.visit(node.value);
			return retval;
		}

		Optional(node) {
			let p = getPrivate(this, "Optional");
			let element = node.value[0];
			let retval = `${p.pad()}$.OPTION(() => {\n`;
			++p.indent;
			retval += this.visit(element);
			--p.indent;
			retval += `${p.pad()}});\n`
			return retval;
		}

		Repeated(node) {
			let p = getPrivate(this, "Repeated");
			let element = node.value[0];
			let retval = `${p.pad()}$.MANY(() => {\n`;
			++p.indent;
			retval += this.visit(element);
			--p.indent;
			retval += `${p.pad()}});\n`
			return retval;
		}

		Group(node) {
			let element = node.value[0];
			let retval = this.visit(element);
			return retval;
		}

		Identifier(node) {
			let p = getPrivate(this, "Identifier");
			return `${p.pad()}$.SUBRULE(${node.value});\n`;
		}

		Terminal(node) {
			let p = getPrivate(this, "Terminal");
			let term = this.visit(node.value[0]);
			p.vocabulary.push(term);
			return `${p.pad()}$.CONSUME(${term});\n`;
		}

		DQ_String(node) {
			let retval = node.value;
			return retval;
		}

		SQ_String(node) {
			let retval = node.value;
			return retval;
		}
	}

	let { makePrivates, getPrivate } = createClassHelpers({
		classDef: EBNF_AST2JS,
		privateData: pvtData
	});

	return EBNF_AST2JS;
})();
