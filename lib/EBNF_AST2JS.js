const createClassHelpers = require("./classHelpers");
const ASTVisitor = require("./ASTVisitor");

module.exports = (function() {
	function pvtData() {
		return {
			functions: {},
			terminalIndex: 0,
			terminalMap: new Map,
			indent: 0,
			pad() {
				let p = getPrivate(this, "pad", true);
				return Array(p.indent+1).join("    ");
			},
			getRegex(term) {
				let chars = term.split();

				for (let i=0; i<chars.length; ++i) {
					if ("{}()[]?>*+-".includes(chars[i])) {
						chars[i] = "\\" + chars[i];
					}
				}

				return RegExp(chars.join()).toString();
			},
			getTerminalID(term) {
				let p = getPrivate(this, "getTerminalID", true);
				if (!p.terminalMap.has(term)) {
					p.terminalMap.set(term, p.terminalIndex++);
				}

				return `VocabTerm${p.terminalMap.get(term)}`;
			}
		};
	}

	class EBNF_AST2JS extends ASTVisitor {
		constructor(types) {
			super(types);
			let p = makePrivates(this, new.target);

			this.validateVisitor();
		}

		Grammar(node) {
			let p = getPrivate(this, "Grammar");
			let retval = `//Generated By chevrotain_ebnf\n` +
						 `const { Lexer, Parser, createToken, createSyntaxDiagramsCode } = require("chevrotain");\n` +
						 `const fs = require("fs");\n\n`;

			//Parse the rules first. This gets us rule definitions and
			//vocabulary items.
			p.indent = 3;
			for (let rule of node.rules) {
				p.functions[rule.name.value] = this.visit(rule);
			}
			p.indent = 0;

			//Don't forget to go back and collect the vocabulary...
			retval += `let Vocabulary = {\n`;
			++p.indent;

			for (let [term] of p.terminalMap) {
				let vocabName = p.getTerminalID(term);
				retval += `${p.pad()}${vocabName}: createToken({\n`;
				++p.indent;
				retval += `${p.pad()}name: \`/${vocabName}/\`,\n`;
				retval += `${p.pad()}pattern: ${p.getRegex(term)},\n`;
				--p.indent;
				retval += `${p.pad()}}),\n`
			}
			--p.indent;
			retval += `${p.pad()}};\n\n`;

			//Extract the tokens from the vocabulary.
			retval += `${p.pad()}let Tokens = Object.values(Vocabulary);\n\n`;

			//Finally, time to create the parser class
			retval += `${p.pad()}module.exports = class extends Parser {\n`;
			++p.indent;
			retval += `${p.pad()}constructor(source, config) {\n`;
			++p.indent;
			retval += `${p.pad()}let lexer = new Lexer(Tokens);\n`;
			retval += `${p.pad()}let lexResult = lexer.tokenize(source);\n\n`;
			retval += `${p.pad()}if (lexResult.errors.length > 0) {\n`;
			++p.indent;
			retval += `${p.pad()}throw new Error(collectLexerErrors(lexResult.errors));\n`;
			--p.indent;
			retval += `${p.pad()}}\n\n`;
			retval += `${p.pad()}super(Vocabulary, config);\n`;
			retval += `${p.pad()}let tokens = lexResult.tokens;\n`;
			retval += `${p.pad()}let $ = this;\n`;

			//Add the class definition after the vocabulary
			//Define the rules that build the syntax.
			for (let rule in p.functions) {
				retval += `${p.pad()}$.RULE("${rule}", () => {\n`;
				++p.indent;
				retval += p.functions[rule];
				--p.indent;
				retval += `${p.pad()}});\n\n`;
			}
			
			retval += `${p.pad()}this.performSelfAnalysis();\n`;
			--p.indent;
			retval += `${p.pad()}}\n`;
			--p.indent;

			//Add function for saving syntax diagrams.
			++p.indent;
			retval += `${p.pad()}saveSyntaxDiagram(filename) {\n`;
			++p.indent;
			retval += `${p.pad()}let serializedGrammar = this.getSerializedGastProductions();\n\n`;
			retval += `${p.pad()}// create the HTML Text\n`;
			retval += `${p.pad()}let htmlText = createSyntaxDiagramsCode(serializedGrammar);\n\n`;
			retval += `${p.pad()}// Write the HTML file to disk\n`;
			retval += `${p.pad()}fs.writeFileSync(filename, htmlText)\n`;
			--p.indent;
			retval += `${p.pad()}}\n`;
			--p.indent;
			retval += `${p.pad()}};\n`;

			return retval;
		}

		Rule(node) {
			let p = getPrivate(this, "Rule");
			return this.visit(node.definition);
		}

		Definition(node) {
			let p = getPrivate(this, "Definition");
			let retval = "";
			let needOR = node.alternatives.length > 1
			let first = true;
			
			if (needOR) {
				retval += `${p.pad()}$.OR([\n`;
				++p.indent;
			}

			for (let alt of node.alternatives) {
				if (needOR) {
					if (first) {
						first = false;
					}
					else {
						retval += `${p.pad()}},\n`;					
					}
					retval += `${p.pad()}{\n`;
					++p.indent;
					retval += `${p.pad()}Alt: () => {\n`;
					++p.indent;
				}
				retval += this.visit(alt);
				if (needOR) {
					--p.indent;
					retval += `${p.pad()}}\n`;
					--p.indent;
				}
			}
			
			if (needOR) {
				retval += `${p.pad()}}\n`;
				--p.indent;
				retval += `${p.pad()}]);\n`;
			}

			return retval;
		}

		Sequence(node) {
			let retval = "";
			
			for (let element of node.value) {
				retval += this.visit(element);
			}

			return retval;
		}

		Alternate(node) {
			let retval = this.visit(node.value);
			return retval;
		}

		Optional(node) {
			let p = getPrivate(this, "Optional");
			let element = node.value[0];
			let retval = `${p.pad()}$.OPTION(() => {\n`;
			++p.indent;
			retval += this.visit(element);
			--p.indent;
			retval += `${p.pad()}});\n`
			return retval;
		}

		Repeated(node) {
			let p = getPrivate(this, "Repeated");
			let element = node.value[0];
			let retval = `${p.pad()}$.MANY(() => {\n`;
			++p.indent;
			retval += this.visit(element);
			--p.indent;
			retval += `${p.pad()}});\n`
			return retval;
		}

		Group(node) {
			let element = node.value[0];
			let retval = this.visit(element);
			return retval;
		}

		Identifier(node) {
			let p = getPrivate(this, "Identifier");
			return `${p.pad()}$.SUBRULE($.${node.value});\n`;
		}

		Terminal(node) {
			let p = getPrivate(this, "Terminal");
			let term = this.visit(node.value[0]);
			return `${p.pad()}$.CONSUME(Vocabulary.${p.getTerminalID(term)});\n`;
		}

		DQ_String(node) {
			let retval = node.value;
			return retval;
		}

		SQ_String(node) {
			let retval = node.value;
			return retval;
		}
	}

	let { makePrivates, getPrivate } = createClassHelpers({
		classDef: EBNF_AST2JS,
		privateData: pvtData
	});

	return EBNF_AST2JS;
})();
